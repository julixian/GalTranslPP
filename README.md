# GalTransl++

![GalTransl++ GUI](https://github.com/julixian/GalTranslPP/blob/master/img/GalTranslPP.png?raw=true)

**GalTransl++** 是继承了 [GalTransl](https://github.com/GalTransl/GalTransl) 以项目为基本的主要理念及架构，凝练其两年间积累的精华部分，同时吸收了大量Gal补丁作者经验而进行优化的，轻量透明的、拥有高度且方便的扩展能力的翻译核心。

**GalTransl++ GUI** 是包装了GalTransl++核心的，以 `在GUI下尽可能保持高度自定义` 为目标的，Fluent UI风格的交互界面，也是本项目的重点开发对象。

## ✨ 特性

本项目在继承了GalTransl基本功能的基础上，包括但不限于对以下模块进行了优化：

*   更好的单文件分割缓存命中
*   优先标点的换行修复
*   可选(带icu扩展的)正则形式的，高度自定义的译前译后字典和明确的优先级
*   高度自定义的epub提取
*   有效的API额度耗尽检测
*   卡片弹出式的完成提示 (仅GUI)
*   更好的字典未使用检测
*   可自定义的符号检测
*   单独生成用以检查的预处理结果
*   统合生成的翻译问题概览
*   速度更快的rebuild
*   更加方便的提示词自定义
*   更清晰的字典使用设定
*   重翻时附带已知问题

![notification](https://github.com/julixian/GalTranslPP/blob/master/img/notification.png?raw=true)

## 📖 流程说明

### GalTransl++ 翻译流程与替换型字典介绍

对于熟悉GalTransl的人来说，过渡到GalTransl++ CLI版本可谓易如反掌，所以接下来主要讲GUI。
这里还是再稍微谈一下翻译流程吧(默认你已经读过GalTransl的使用说明，翻译接口什么的就略过了)。

GalTransl++无论处理哪种文件格式，最后都是统一化为json来读取。
每个json文件是一个对象列表，每个对象代表一个『句子』，这是喂给AI进行翻译的基本单位。
读取json时主要关注两个键，分别为 `name` 和 `message`，不同的翻译模式(`transEngine`)就是对这两个键进行各种不同的处理：

#### 翻译模式 (transEngine)

*   **`# ForGalJson`**: 实际翻译模式，向AI输入json格式的句子(包含`name`和`message`)并要求AI以json格式回复，程序将解析返回的Json。
*   **`# ForGalTsv`**: 实际翻译模式，向AI输入TSV格式的句子(包含`name`和`message`)并要求AI以TSV格式回复，程序将解析返回的TSV，可能比ForGalJson模式更省token。
*   **`# ForNovelTsv`**: 实际翻译模式，和 `ForGalTsv` 的区别主要是变动提示词，向AI输入和解析的时候都不带`name`键。
*   **`# DeepseekJson`**: 实际翻译模式，和 `ForGalJson` 的唯一区别是程序自带的默认提示词变成了中文。
*   **`# Sakura`**: 实际翻译模式，向AI输入自然语言形式的句子(包含`name`和`message`)，由于Sakura是翻译特化模型，不必要求即会返回同样形式的的句子，程序解析返回的自然语言。
*   **`# DumpName`**: 提取所有的 `name` 键，在项目文件夹下生成 `人名替换表.toml` 以供统一替换人名。
*   **`# GenDict`**: 借助AI自动生成术语表，保存在项目文件夹下的 `项目GPT字典-生成.toml` 中。
*   **`# Rebuild`**: 即使 `problem` 或 `orig_text` 中包含 `retranslKey` 也不会重翻，只根据缓存重建结果。
*   **`# ShowNormal`**: 保存预处理后的内容及句子到项目文件夹下带 `show_normal` 字段的文件夹中，如Epub格式下可生成预处理后的html/xhtml文件以及生成的json，可用于检查和排错。

### 缓存机制

在`Rebuild`中所提到的缓存，是指翻译过后留存在项目文件夹下，`trans_cache`文件夹中的json文件，其中按顺序存储了每个文件对应的序列号，原文和译文等信息。所有的实际翻译模式都会先读取缓存，然后只挑选出缓存中还没有的原文进行翻译。

> **⚠️ 特别注意**：在使用单文件分割功能的情况下，由于缓存命中结合了上下文，所以当你改变文件本身，或者分割数/分割方式时，会有一部分无关的句子不能命中缓存。理论上文件切的越碎，最终分割出的文件份数比最大线程数超过的更多，则不能命中缓存的句子越多。GalTransl++会尽可能在这种情况下保证原有缓存的命中，不过如果希望达到更好的缓存命中，最好还是不改变分割方式和分割数。为此也可以使用 `ShowNormal` 模式观察切割后的文件。

`retranslKey`指的是重翻关键字，`problem`指的是缓存中的问题。
GalTransl++会在翻译时自动分析翻译时常见问题，并将问题输出到缓存中。
一般情况下，如果 `problem` 或 `orig_text`(一个缓存键，存储的是原始message) 中包含设定的`retranslKey`，则即使在实际翻译模式下命中缓存，这个句子依然会被重翻。所以如果只想重建缓存，要么得删除所有`retranslKey`，要么使用 `Rebuild` 模式忽略翻译。

### 字典系统

GalTransl++的字典分为 **译前字典**，**GPT字典**，**译后字典** 三大类。每类字典都有 **通用** 和 **项目** 两种。
顾名思义，通用字典可以被所有项目所见，项目字典只能被当前项目所见。
具体一个项目要用哪些字典，可以在项目的 `翻译设置->字典设置` 中找到对应的选项进行选择。

这三类字典中，译前和译后字典为 **替换型字典**，GPT字典为 **提示型字典**。
即译前和译后字典执行的是搜索替换，而GPT字典的作用仅在于当原文中出现字典里的词时，将该条字典作为附加部分一并喂给AI以规范翻译，那至于AI想不想用，用成什么样，就不是程序能管得到的了。

#### GUI中的字典处理

*   **文件对应关系**
    *   通用字典可以有多个，而项目字典和人名表每个项目各只有一个。
    *   GUI会读取项目文件夹下 `人名替换表.toml` 来作为 **人名表** 中的数据。
    *   读取 `项目字典_译前.toml` 来作为 **项目译前字典** 中的数据。
    *   读取 `项目GPT字典.toml` 和 `项目GPT字典-生成.toml` 并合并其中的数据来作为 **项目GPT字典** 中的数据。
    *   读取 `项目字典_译后.toml` 来作为 **项目译后字典** 中的数据。

*   **编辑模式与保存逻辑**
    *   人名表和字典都分别有 **纯文本模式** 和 **表模式**，具体在翻译时用哪个模式的数据会在你按开始翻译按钮时决定。
    *   例如，你在按开始翻译按钮时，人名表是以表模式显示的，则会先将 **人名表(表模式)** 中的数据保存到 `人名替换表.toml` 中，然后再执行翻译。如果在纯文本模式下没有按 toml 格式来编辑，翻译时肯定会报错。
    *   按 **刷新** 将会重新从项目文件夹中的 toml 文件读取数据。如果你在GUI中还有修改了没有保存的数据，请务必先确认备份情况再刷新。
    *   按 **保存** 会在保存的同时刷新另一模式的数据。比如在纯文本模式中编辑后按下保存，则此时表模式也会更新刚刚编辑过的内容。

> **⚠️ 注意**：由于`DumpName`/`GenDict`任务会分别生成 `人名替换表.toml` / `项目GPT字典-生成.toml` 并覆盖原有文件，默认也会在任务结束后自动刷新，所以请务必注意不要被其覆盖掉有用的信息。

### 一个常见的翻译流程

1.  新建项目 -> 输入项目名。
2.  在新建的项目文件夹中的`gt_input`文件夹中放入待翻译的文件。
3.  填入API和key。
4.  使用 `GenDict` 自动生成术语表。
5.  调整术语表，根据需求修改字典并选择要使用的字典。
6.  如果文件支持提取name，则可 `DumpName` 并编辑人名表。
7.  选用合适的实际翻译模式进行翻译。
8.  查看问题。
9.  根据问题选择编辑`retranslKey`并重翻 / 直接修改缓存。
10. 重翻 / 重建。
11. 在`gt_output`中查收结果。

### 缓存文件结构

GalTransl++的缓存中可能包含如下键:

*   `index`: 索引顺序，一般不重要。
*   `name`: 人名，展示的是预处理后的人名(相当于pre_processed_name)，如果没有则为空。
*   `name_preview`: 将输出的译后人名。
*   `original_text`: 原文对照，与原文没有任何区别。
*   `pre_processed_text`: 经过一系列预处理后，即将执行AI翻译前时句子的样子。
*   `pre_translated_text`: AI返回的，未经过任何后处理的句子的样子。
*   `problem`: 在自动化找错中找出的问题。
*   `translated_by`: 翻译此句子所用的 apikey 的设定模型。
*   `translated_preview`: 经过所有后处理之后，将输出的 message。
*   `other_info`: 其它附加信息。

### 替换型字典语法

*   **译前字典** 会搜索并替换 `original_text` 以输出 `pre_processed_text` 提供给AI。
*   **译后字典** 会搜索并替换 `pre_translated_text` 以供 `translated_preview` 最终输出。

**条件对象** 是指条件正则要作用于的文本，可以是 `name`, `orig_text`, `preproc_text`, `pretrans_text` 中的任意一个。

当 **启用正则** 为 `true` 时，原文和译文将被视为正则表达式进行替换，优先级越高的字典越先执行。

## ⚙️ 处理与翻译顺序

1.  可选: 对 `name` 执行译前字典替换 (人名表收集的也是这一步后的 `name`)。
2.  将 `message` 中的换行统一替换为 `<br>`。
3.  将 `message` 中的制表符统一替换为 `<tab>`。
4.  可选: 对 `message` 执行译前字典替换。
5.  执行前处理插件。
6.  **AI翻译**。
7.  执行后处理插件。
8.  可选: 对 `message` 执行译后字典替换。
9.  将 `message` 中的 `<tab>` 统一替换回制表符。
10. 将 `message` 中的换行从 `<br>` 换回原符号。
11. 可选: 对 `name` 执行GPT字典替换 (此时GPT字典将被临时视为替换型字典)。
12. 对 `name` 执行人名表替换 (人名表译名为空则忽略)。
13. 可选: 对 `name` 执行译后字典替换。
14. 问题分析。

> **正则引擎说明**
>
> 虽然GalTransl++的核心为C++编写，但由于正则引擎采用`icu::Regex`，所以可自定义编辑的所有正则依然是以字符为单位的。比如即使emoji表情'😪' 在UTF-8中占用4个字节，在正则中依然是以一个`.`来匹配的。
> 同时也支持icu扩展正则语法，如可以使用`\p{P}`来匹配任意标点符号，`\p{Hangul}`来匹配任意韩文字符等。

## 🤝 贡献指南

GalTransl++在文件支持和插件支持上仍处于起步阶段，也不排除有其它优化的思路或需要修改的bug，如果有疑问或建议，欢迎提出 issue 或 PR。接下来主要说一下如何添加文件处理器/插件。

### 添加文件处理器 (Translator)

如你所见，GalTransl++的核心代码文件数量不超过二十个，接口也十分简单。
由于所有的文件处理器需直接/间接继承自 `ITranslator`，如无特殊情况，一般直接继承 `NormalJsonTranslator` 即可。
这样只需要将相应文件提取为json，并重设提取文件夹为 `NormalJsonTranlator` 的 `inputDir` 文件夹，
重设期望获取译后json的文件夹为其 `outputDir` 文件夹即可。
每当其翻译完一个文件时(如果有单文件分割则只在文件合并后)，其会调用成员变量中的函数对象 `m_onFileProcessed`(线程安全)，
可以借此来判断文件的写回时机，具体示例可见 `EpubTranslator`。

需要注册的工厂函数为 `createTranslator`。

### 添加插件处理器 (Plugin)

文本处理插件理论上分为前处理插件和后处理插件，GalTransl++不接受希望同时在译前和译后都生效的插件，那样会破坏对于插件处理顺序的自定义性。如果有需要请将您的插件分为 Pre版 和 Post版。

所有插件均需继承自 `IPlugin`，并实现 `run` 方法，仅此即可。

*   **对于译前插件**：如果是非过滤型插件，原则上只允许修改 `pre_processed_text`。如果是过滤型插件，可以将 `complete` 置为 `true`，并负责填充 `pre_translated_text`。如有需要，也可以在 `other_info` 中插入信息键，以便之后在 `problemAnalyzer` 中过滤带此键的问题分析等。
*   **对于译后插件**：原则上只允许修改 `translated_preview`。

任意插件均可在 `other_info` 中插入键以在缓存中附带信息。
具体示例可见 `TextLinebreakFix` 和 `TextPostFull2Half`。

需要注册的工厂函数为 `registerPlugins`。

### 其它注意事项

由于我的开发环境基本绑定 windows系统，我自己也没有linux设备，所以即使在项目中使用的winapi数量很少也很好替换，
但是跨平台的事我自己是不会主动考虑的。
另外由于我所使用的环境较新，也可能会有一些比较罕见的问题。
目前已知项目依赖 `mecab:x64-windows` 在VS2026(工具集 v145)下不过编，但是VS2022(工具集 v143)能过，安装依赖可能需要切回VS2022
